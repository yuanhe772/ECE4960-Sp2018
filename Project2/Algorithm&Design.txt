############ Modular Programming Design: ############

The program breaks down into 5 classes, SparseMatrix.java, Vector.java, Jacobi.java, Test.java, and Main.java.
The first two classes are designed for the ease of isolation between different data structures. These two classes also implemented the basic operations, including matrix's addition/subtraction, multiplication, element-retrieving, value-setting, and Jacobi-Decomposition in SparseMatrix, and vector's addtion/subtraction in Vector.
Jacobi.java utilizaed the matrixes generated from SparseMatrix.java, and implemented the iterative steps for solving Ax = b.


############ Testing Design: ############
The Test.java class tests all functions in SparseMatrix.java and Vector.java (except of its three constructors, because constructors only simply assign values to the class variants), and also the convergence property for Jacobi.java.

The outline for testing: Start with the most basic and independent functions(retrieveElement(), matrixSetter(), Vector.add() for instance), and then move on to the functions that have depencencies on other functions. Before testing with Jacobi-solver, the other functions are tested to provide a verified foundation for Jacob-solver's convergence testing.

The methods for testing: all SparseMatrix and Vector testing are based on Wilkinson Principle, namely to check whether two methods generate the same outputs. The basic and simpler functions (retrieveElement(), matrixSetter(), Vector.add() for instance) are tested with small testing data generated in-code, and they are white-box tested, because smaller and less dependent functions are more robust; The more complex functions are tested with Python generated large data (having the same rank as mat1 to ensure robustness), and they are black-box tested, because if they are capable of providing foundations for the ultimate Jacobi-Iterative-Solver, which uses mat1(a matrix without knowing the ground truth) as input, they have to be able to correctly solve a black-boxed matrix that's as large as the mat1(having the same rank).

The testing procedures: each function is tested for both its input (whether the inputs satisfy the function's invariants, for instance, for retrieving element(i,j) from a sparse matrix with rank of 5, "0 <= i,j < 5" has to be satisfied), and output correctness(whether this function generated desired correct outcome, by comparing the result with another result generated by a seperated verified method, if their second norm difference "||difference||" is zero, then test is passed).
